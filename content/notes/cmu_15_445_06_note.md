---
title: "CMU::15-445/645::Tree Indexes 笔记"
date: 2021-09-22T08:41:54+08:00
draft: false
---

## 树形索引第一部分

![img](https://i.imgur.com/RK21nhh.png)

### 表索引

在数据库系统中，有许多不同的数据结构，可以用于内部元数据、核心数据存储、临时数据结构或表索引等目的。对于表索引，可能涉及到带有范围扫描的查询。

表索引是一个表的列的子集的副本，它被组织和(或)排序，以使用这些属性的子集进行有效的访问。因此，DBMS 可以查询表索引的辅助数据结构，而不是进行顺序扫描，以更快地找到元组。DBMS 确保表和索引的内容在逻辑上总是同步的。

在每个数据库要创建的索引数量之间存在着一个权衡。尽管更多的索引使得查询速度更快，但索引也会使用存储空间并需要维护。DBMS 的工作是找出用于执行查询的最佳索引。

### B+树

B+Tree 是一种自平衡的树形数据结构，它可以保持数据的分类，并允许在 O(log(n))中进行搜索、顺序访问、插入和删除。它为面向磁盘的 DBMS 的读/写大型数据块而优化。

几乎所有支持保序索引的现代 DBMS 都使用 B+Tree。有一种特定的数据结构叫做 B-Tree，但是人们也用这个词来泛指一类数据结构。原始的 B-Tree 和 B+Tree 之间的主要区别是，B-Tree 在所有节点中存储键和值，而 B+Tree 只在叶节点中存储值。现代 B+Tree 的实现结合了其他 B-Tree 变体的特征，例如 B\\(^{link}\\)-Tree 中使用的兄弟姐妹指针。

![img](https://i.imgur.com/W8jH3GU.png)

从形式上看，B+树是一棵具有以下特性的 M-way 搜索树。

- 它是完全平衡的（即，每个叶子节点都在相同的深度）。
- 除根以外的每个内部节点至少有一半是满的（M/2 - 1 <= 键的数量 <= M - 1）。
- 每个有 k 个键的内部节点都有 k+1 个非空子节点。

B+Tree 中的每个节点都包含一个键/值对数组。这些对中的键是由索引所基于的属性派生的。这些值将根据一个节点是内部节点还是叶子节点而有所不同。对于内部节点，值数组将包含指向其他节点的指针。叶子节点值的两种方法是记录 ID 和元组数据。记录 ID 指的是一个指向元组位置的指针。有元组数据的叶子节点在每个节点中存储元组的实际内容。

每个节点的数组都（几乎）是按键排序的。

![img](https://i.imgur.com/gerdPnT.png)

实践中节点中键和值是分开存储的

![img](https://i.imgur.com/qa9zakg.png)

#### 插入

要在 B+树中插入一个新的条目，必须沿着树向下遍历，并使用内部节点来确定将值插入哪个叶子节点。

- 找到正确的叶子 L。
- 按排序顺序将新条目添加到 L 中。
  - 如果 L 有足够的空间，操作就完成了。
  - 否则将 L 分成两个结点 L 和 L2。均匀地重新分配条目，并将中间的键复制上去。 将指向 L2 的索引条目插入 L 的父节点中。
- 要分割一个内部节点，均匀地重新分配条目，但要把中间的键向上推。

[可视化演示网址](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

#### 删除

在插入过程中，当树变得太满时，我们偶尔不得不分割叶子，而如果删除导致树少于半满，我们必须进行合并，以重新平衡树。

- 找到正确的叶子 L。
- 删除条目。
  - 如果 L 至少有一半是满的，那么操作就完成了。
  - 否则，你可以尝试重新分配，从兄弟姐妹那里借用。
  - 如果重新分配失败，则合并 L 和同胞。
- 如果合并发生了，你必须删除父类中指向 L 的条目。

[可视化演示网址](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

#### 条件选择

因为 B+Tree 是按排序的，查找时遍历速度很快，也不需要整个键。如果查询提供了搜索键的任何属性，DBMS 可以使用 B+Tree 索引。这与散列索引不同，散列索引需要搜索键中的所有属性。

#### 非唯一索引

像散列表一样，B+Trees 可以通过重复键或存储值列表来处理非唯一的索引。在重复键的方法中，使用相同的叶子节点布局，但重复的键被多次存储。 在值列表的方法中，每个键只存储一次，并保持一个唯一值的链接列表。

#### 重复键

在 B+Tree 中，有两种方法来重复键。

第一种方法是将记录 ID 作为键的一部分来附加。由于每个元组的记录 ID 是唯一的，这将确保所有的键都是可识别的。DBMS 可以根据部分键来查找元组。

第二种方法是允许叶子节点溢出到包含重复键的溢出节点。 虽然没有多余的信息被存储，但这种方法的维护和修改更加复杂。

#### 聚簇索引

表按照主键指定的排序顺序存储，作为堆组织的或索引组织的存储。 由于一些 DBMS 总是使用聚簇索引，如果一个表没有明确的主键，它们会自动地将隐藏的行 ID 作为主键，但是其他的 DBMS 根本就不能使用它们。

#### 堆聚簇

元组在堆的页面中使用聚簇索引指定的顺序进行排序。如果聚类索引的属性被用来访问元组，DBMS 可以直接跳到这些页面。

#### 索引扫描页排序

由于直接从非聚簇索引中检索元组的效率很低，DBMS 可以首先找出它所需要的所有元组，然后根据它们的页面 id 进行排序。
