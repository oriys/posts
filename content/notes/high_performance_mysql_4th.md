---
title: "数据库::高性能MySQL第四版笔记"
date: 2021-12-19T16:11:52+08:00
draft: false
---

## MySQL 架构

### MySQL 的逻辑架构

MySQL 的架构分为三层  
最上面一层是客户端，它们是大多数基于网络的客户/服务器工具或服务器需要的服务：连接处理、认证、安全，等等。  
第二层包含 MySQL 的大多数功能，包括提供查询解析、分析、优化的代码，以及所有的内置函数。任何跨存储引擎提供的功能都在这一层：例如，存储过程、触发器和视图。  
第三层包含存储引擎。它们负责存储和检索 "在 "MySQL 中存储的所有数据。像 GNU/Linux 的各种文件系统一样，每个存储引擎都有自己的好处和缺点。服务器通过存储引擎 API 与它们进行通信。

### 连接管理和安全

默认情况，每个客户端连接都有单独的处理线程，服务器缓存了就绪的线程，避免了每次连接创建和销毁的开销。  
当客户端连接到服务器，服务器会进行登录信息鉴权和操作权限校验。

### 优化和执行

MySQL 解析查询以创建一个内部结构（解析树），然后应用各种优化。这些可能包括重写查询，确定它将读取表的顺序，选择使用哪些索引，等等。你可以通过查询中的特殊关键字向优化器传递提示，影响其决策过程。你还可以要求服务器解释优化的各个环节，以便重新修改查询、模式和设置，使一切尽可能有效地运行。  
优化器并不真正关心一个特定的表使用什么存储引擎，但存储引擎确实影响到服务器如何优化查询。例如，一些存储引擎支持索引类型，这对某些查询是有帮助的。  
MySQL 的内部缓存随着并发的增加成为了瓶颈，所以在 MySQL8.0 中已经彻底去掉。

### 并发控制

任何时候，只要有一个以上的查询需要同时改变数据，就会出现并发控制的问题。MySQL 必须在两个层面上做到这一点：服务器层面和存储引擎层面。

### 读写锁

处理并发读/写访问的系统通常实现一个由两种锁类型组成的锁系统。这些锁通常被称为共享锁和独占锁，或者读锁和写锁。一个资源上的读锁是共享的，或者说是相互不阻塞的：许多客户可以同时从一个资源上读取，而不会相互干扰。另一方面，写锁是排他性的--也就是说，它们同时阻止读锁和其他写锁--因为唯一安全的策略是在给定的时间内只有一个客户在向资源写，并且在客户写的时候阻止所有的读。

### 锁的粒度

每一个锁操作都有开销，包括获取锁、检查锁是否空闲、释放锁，等等。如果系统花费太多的时间来管理锁，而不是存储和检索数据，性能就会受到影响。管理锁是存储引擎设计中的一个非常重要的决定；将粒度固定在某一水平上可以提高某些用途的性能，但使该引擎不适合其他用途。

- 表锁  
  MySQL 中最基本的锁策略，也是开销最小的策略，是表锁。当一个客户希望对一个表进行写操作时（插入、删除、更新等），它获得一个写锁。这使得所有其他的读和写操作都无法进行。当没有人写时，读者可以获得读锁，这不会与其他读锁冲突。  
  表锁在特定情况下有一些变化以提高性能。例如，READ LOCAL 表锁允许某些类型的并发写操作。写和读锁队列是分开的，写队列的优先级完全高于读队列。
- 行锁  
  提供最大并发性的锁定方式（也有最大的开销）是使用行锁。这使得服务器可以进行更多的并发写操作，但代价是必须跟踪谁拥有每一个行锁，它们被打开了多长时间，它们是什么样的行锁，以及在不再需要时清理锁的开销。  
  推荐阅读：[MySQL :: MySQL 8.0 Reference Manual :: 15.7.1 InnoDB Locking](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)

### 事务

事务是一组被原子化处理的 SQL 语句，是一个单一的工作单位。所有操作应该被包裹在一个事务中，这样，如果任何一个步骤失败，任何已完成的步骤都需要回滚。

事务需要满足 ACID 特性。

- 原子性  
  事务必须作为一个单一的不可分割的工作单元来运作，这样整个事务要么被应用，要么永远不会提交。当事务是原子性的，就不存在部分完成的事务：要么全部完成，要么什么都没有。
- 一致性  
  数据库应该总是从一个一致的状态移动到下一个一致的状态。
- 隔离性  
  一个事务的结果通常对其他事务是不可见的，直到该事务完成。
- 持久性  
  一旦提交，事务的变化就是永久性的。这意味着这些变化必须被记录下来，以便在系统崩溃时数据不会丢失。

### 隔离级别

ANSI SQL 标准定义了四个隔离级别。这个标准的目标是定义在事务内部和外部哪些变化是可见的，哪些是不可见的规则。较低的隔离级别通常允许较高的并发性，并具有较低的开销。

- 读未提交  
  在 READ UNCOMMITTED 隔离级别中，事务可以查看未提交的事务的结果。取未承诺的数据也被称为脏读。
- 读未提交  
  一个事务将继续看到在它开始后提交的事务所做的更改，而它的更改在它提交前不会被其他人看到。这个级别仍然允许所谓的不可重复的读取。这意味着你可以运行同一个语句两次而看到不同的数据。
- 可重复读  
  REPEATABLE READ 解决了 READ UNCOMMITTED 允许的问题。它保证一个事务读取的任何行在同一事务的后续读取中看起来是一样的，但理论上它仍然没解决另一个棘手的问题：幻读。简单的说，当你选择了一些行的范围，另一个事务在这个范围内插入了一条新的行，然后你再次选择相同的范围，你就会看到新的"幻影"行，这时就会发生幻读。InnoDB 和 XtraDB 通过多版本并发控制来解决幻读问题。  
  REPEATABLE READ 是 MySQL 的默认事务隔离级别。
- 序列化  
  最高级别的隔离，SERIALIZABLE，通过强制事务顺序执行，使其不可能发生冲突，从而解决了幻读问题。简而言之，SERIALIZABLE 在其读取的每一行上都加了一个锁。在这个层面上，可能会出现大量的超时和锁争夺。

### 死锁

死锁是指两个或更多的事务在相同的资源上相互持有和请求锁，形成一个依赖性的循环。当事务试图以不同的顺序锁定资源时就会发生死锁。只要有多个事务锁定相同的资源，它们就会发生。  
数据库系统实现了各种形式的死锁检测和超时。更复杂的系统，比如 InnoDB 存储引擎，会注意到循环依赖关系，并立即返回一个错误。这可能是一件好事--否则，死锁会表现为非常缓慢的查询。其他的会在查询超过锁等待超时后放弃，这并不总是好事。InnoDB 目前处理死锁的方式是回滚拥有最少独占行锁的事务。  
一旦发生死锁，如果不回滚其中一个事务，死锁就不能被打破，无论是部分还是全部。它们是事务系统中的一个事实，你的应用程序应该被设计成能够处理它们。许多应用程序可以简单地从头开始重试他们的事务，除非他们遇到另一个死锁，否则他们应该是成功的。

### 事务日志

### MySQL 中的事务

### 多版本并发控制

### 复制

### 数据文件结构

### InnoDB 引擎

### JSON 文档支持

### 数据字典变化

### 原子 DDL
