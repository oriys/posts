---
title: "深入理解计算机系统"
date: 2021-04-09T00:17:05+08:00
draft: true
---

# 深入理解计算机系统

## 计算机系统漫游

### 信息就是位 + 上下文

- 文件分为文本文件和二进制文件。
- 8 个比特被组织成一组，称为字节。
- 系统中所有的信息：包括磁盘文件，内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法就是我们读到这些数据对象时的上下文呢。在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。

### 程序被其他程序翻译成不同的格式

- 预处理阶段：预处理器根据以字符#开头的命令，修改原始的 C 程序。
- 编译阶段：编译器将预处理后的文本文件翻译成包含汇编语言程序的文本文件。
- 汇编阶段：汇编器将包含低汇编语言程序的文本文件翻译成机器语言指令，并将结果保存在目标文件中，目标文件是一个二进制文件。
- 链接阶段：链接器以某种方式合并程序中调用的函数预编译目标中间，最终得到一个可执行文件，可以被加载到内存中，有系统执行。

### 了解编译系统如何工作是大有益处的

- 优化程序性能
- 理解链接时出现的错误
- 避免安全漏洞

### 处理器读并解释储存在内存中的指令

#### 系统的硬件组成

- 总线
  - 贯穿整个系统的一组电子管道
  - 负责携带信息字节并负责在各个部件中传递。
  - 通常总线被设计成传递定长的字节块，称为字(word)，不同机器上字长不一致，需要具体的上下文判断。
- I/O 设备
  - I/O 设备是系统与外部世界的联系通道。
  - 每个 I/O 设备通过一个控制器或适配器与 I/O 总线相连。
    - 控制器是 I/O 设备本身或者系统的主印刷电路板上的芯片组。
    - 适配器是一块插在主板插槽上的卡。
- 主存
  - 主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序所处理的数据。
  - 从物理角度来说，主存是由一组 DRAM 芯片组成的。
  - 从逻辑上来说，存储器是一个线性的字节数据，每个字节都有其唯一的地址。
  - 组成程序的每条机器指令有不同数量的字节构成。
- 处理器
  - CPU，解释或者执行存储在内存中指令的引擎。
  - 程序计数器 PC，在任何时候，PC 都指向主存中的某条机器语言指令。
  - 寄存器文件，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。
  - ALU，算数逻辑单元，负责做算术运算。

#### 运行程序

- shell 等待输入。
- 输入命令。
- shell 读取命令，并将字符串放到内存中。
- shell 执行一系列指令来加载可执行文件，并将目标文件中的代码和数据从磁盘复制到主存。
- 处理器开始执行程序中 main 程序中的机器语言指令。
- 程序中的数据从主存加载到寄存器文件中。
- 从寄存器文件中复制到显示设备，最终显示到屏幕上。

### 高速缓存至关重要

- 处理器处理数据的速度远远超出从主存读取数据的速度，系统设计者引入了高速缓存存储器作为但是的集结区域，存放处理器近期可能会需要的信息。
- 高速缓存的局部性原理，程序具有访问局部区域里的数据和代码的趋势。

### 存储设备形成层次结构

![一个存储器层次结构的示例](../../..//csapp/IMG_1_9.png)

### 操作系统管理硬件

- 操作系统的两个基本功能
  - 防止硬件被时空的应用程序滥用
  - 向应用程序提供简单一致的机制来控制复杂而又通常不大相同的低级硬件设备。
- 操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现以上功能。
  - 文件是对 I/O 设备的抽象
  - 虚拟内存是对主存和磁盘 I/O 设备的抽象表示
  - 进程是对处理器、主存和 I/O 设备的抽象表示
- 进程
  - 进程是操作系统对一个正在运行的程序的一种抽象。
  - 并发，不同的进程的指令是交错执行的。
  - 多核处理器可以并行执行多个进程。
  - 任何一个时刻，但处理器都只能执行一个进程的代码。
  - 不同进程切换交错执行的机制称为上下文切换，上下文是操作系统保持跟踪进程运行所需的所有状态信息。
- 线程
  - 一个进程由多个称为线程的执行单元组成，每个线程运行在进程的上下文中，共享一部分代码和数据。
- 虚拟内存
  - 提供一种每个进程都独占整片主存的假象。称为虚拟地址空间。
- 文件
  - 文件解释字节序列。
  - 每个 I/O 设备，包括磁盘、键盘、显示器、甚至网络都可以看成是文件。
  - 系统的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的。

### 系统之间利用网络通信

- 现代系统通过网络和其他系统连接在一起
- 网络可视为一个 I/O 设备

### 重要主题

- Amdahl 定律：当我们对系统的某个部分加速时，其对系统的影响取决于该部分的重要性和加速程度。
- 并发与并行
  - 线程级并行
    - 多任务快速切换
    - 多核处理器
    - 超线程技术
  - 指令级并行
    - 现代处理器可以同时执行多条指令
    - 流水线
    - 超标量操作
  - 单指令、多数据并行 SIMD
    - 一条执行产生多个可以并行执行的操作
- 抽象的重要性
  - 虚拟机

### 信息的表示和处理

- 三种重要的数字表示
  - 无符号编码基于传统的二进制表示，表示大于或等于零的数字。
  - 补码编码表示有符号数，可以是正或者负的数字。
  - 浮点数编码表示实数的科学技术法以 2 位基数的版本。
- 整数的计算机运算满足交换律和结合律，浮点数运算不一定满足结合律
- 运算结果溢出问题

#### 信息存储

- 字节, 8 位的块, 最小可寻址内存单元。
- 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存，内存的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合就称为虚拟地址空间。

##### 十六进制表示法

- 几种不同进制的标识
  - 一个字节的二进制值域是 00000000(2) ~ 11111111(2)
  - 一个字节的十进制值域是 0(10) ~ 255(10)
  - 一个字节的十六进制值域是 00(16) ~ FF(16)
- C 语言中，0x 或者 0X 开头的数字常量被认为是十六进制的值。
- 进制转换

##### 字数据大小

- 字长，表明指针数据的标称大小，虚拟地址也是用字来编码的，决定了虚拟地址的范围
- char 类型不保证是正数
- 可移植性的一个方面就是程序对不同数据类型的确切大小不明感，程序员在 32 位系统中用 int 类型来保存地址导致在 64 位系统中出现问题。
- 大部分数据类型都编码为有符号数，除非有关键字 unsigned 或特定方式来声明
- 大多数机器支持两个不同的浮点数格式，单精度 float 和双精度 double

##### 寻址和字节顺序

- 跨越多字节的程序对象的两个规则
  - 对象地址
  - 对象在内存中的排列方式
- 字节顺序
  - 小端法，最低有效字节在最前面
  - 大端法，最高有效字节在最前面
  - 双端法，通过配置选择字节顺序，取决于操作系统
- 顺序的重要性
  - 不同机器之间传输二进制数据，通过网络协议约束字节顺序
  - 阅读整数数据的字节序列时字节顺序的影响
  - 编写规避正常的类型系统的程序

##### 表示字符串

- C 语言中字符串被编码称一个以 null 字符结尾的字符数组，通常以 ASCII 编码。
- 文本数据比二进制数据有更强的平台独立性，在不同平台下都能得到同样的结果。

##### 表示代码

- 同一段文本代码在不同平台的二进制编译结果是不同的。
- 从机器的角度看，程序仅仅只是字节序列。

##### 布尔代数简介

- 将逻辑值 TRUE 和 FALSE 编码为二进制 1 和 0，能够设计出一套代数，以研究逻辑推理的基本原则。
- 对应关系
  - 0 -> TRUE
  - 1 -> FALSE
  - ~ -> NOT
  - & -> AND
  - | -> OR
  - ^ -> EXCLUSIVE-OR

##### C 语言中的位级运算

- C 语言支持按位布尔运算，这些运算能够运用到任何整形数据类型上
- 掩码运算，从一个字中选出位的集合

##### C 语言中的位移运算

- 向左位移 k 位，丢弃最高的 k 位，并在右端补 k 个 0
- 逻辑右移，在左端补 k 个 0
- 算术右移，在左端补 k 个最高有效位的值
- C 对于有符号数右移动没有明确规定，一般假设是算术右移，对于无符号数是逻辑右移

### 整数表示

#### 整数数据类型

- C 语言支持多种整数数据类型来表示有限范围的整数
- C 语言支持无符号数，Java 只支持有符号数

##### 32 位整数典型取值范围

| 类型           | 最小值                     | 最大值                     |
| -------------- | -------------------------- | -------------------------- |
| char           | -128                       | 127                        |
| unsigned char  | 0                          | 255                        |
| short          | -32768                     | 32767                      |
| unsigned short | 0                          | 65,535                     |
| int            | −2,147,483,648             | 2,147,483,647              |
| unsigned int   | 0                          | 4,294,967,295              |
| long           | −2,147,483,648             | 2,147,483,647              |
| unsigned long  | 0                          | 4,294,967,295              |
| int32_t        | −2,147,483,648             | 2,147,483,647              |
| uint32_t       | 0                          | 4,294,967,295              |
| int64_t        | −9,223,372,036,854,775,808 | 9,223,372,036,854,775,807  |
| uint64_t       | 0                          | 18,446,744,073,709,551,615 |

##### 64 位整数典型取值范围

| 类型           | 最小值                     | 最大值                     |
| -------------- | -------------------------- | -------------------------- |
| char           | -128                       | 127                        |
| unsigned char  | 0                          | 255                        |
| short          | -32768                     | 32767                      |
| unsigned short | 0                          | 65,535                     |
| int            | −2,147,483,648             | 2,147,483,647              |
| unsigned int   | 0                          | 4,294,967,295              |
| long           | −9,223,372,036,854,775,808 | 9,223,372,036,854,775,807  |
| unsigned long  | 0                          | 18,446,744,073,709,551,615 |
| int32_t        | −2,147,483,648             | 2,147,483,647              |
| uint32_t       | 0                          | 4,294,967,295              |
| int64_t        | −9,223,372,036,854,775,808 | 9,223,372,036,854,775,807  |
| uint64_t       | 0                          | 18,446,744,073,709,551,615 |

#### 无符号数的编码

假设一个整型数类型为 w 位，我们可以将它的位向量写成 \\(\overrightarrow{x}\\)，或者写成 \\([x_{w-1},x_{w-2},...,x_0]\\) 。我们可以直接将 \\(\overrightarrow{x}\\) 看成是一个二进制表示的，就获得了 \\(\overrightarrow{x}\\) 的无符号表示。定义一个函数 \\(B2U_w\\)（Binary to Unsigned）表示将 w 位的二进制转化为无符号数，我们可以得到对向量 \\(\overrightarrow{x}=[x\_{w-1},x\_{w-2},...,x_0]\\) 该函数的表达式为 $$ B2U_w(\overrightarrow{x})=\sum\_{i=0}^{w-1}{x_i2^i} $$ 函数 \\( B2U_w\\) 将长度为 w 的 0、1 串映射到了非负整数

- w 位所能表示的值的范围
  - 最小值用向量 \\([0,0,...,0]\\) 来表示，值为 0
  - 最大值用向量 \\([1,1,...,1]\\) 来表示，值为整数 \\( UMax_w=\sum\_{i=0}^{w-1}{2^i}=2^w-1 \\)

#### 有符号数的编码

##### 补码

最常见的有符号数的计算机表示就是**补码**形式，在这个定义中，将字的最高有效位解释为负权，我们用函数 \\(B2T_w\\) 来表示，对向量 \\(\overrightarrow{x}=[x\_{w-1},x\_{w-2},...,x_0]\\) $$ B2T_w=-x\_{w-1}2^{w-1}+\sum\_{i=0}^{w-2}x_i2^i $$ 最高有效位 \\(x\_{w-1}\\) 也称符号位，它的权重为 \\(-2^{w-1}\\)，是无符号表示中权重的负数，符号位被设置为 1 时，表示为负，而当设置为 0 时，值为非负。

- w 位所能表示的值的范围
  - 最小值用向量 \\([1,0,...,0]\\) 来表示，值为整数 \\( UMin_w=-2^{w-1}\\)
  - 最大值用向量 \\([0,1,...,1]\\) 来表示，值为整数 \\( UMax_w=\sum\_{i=0}^{w-1}{2^i}=2^w-1 \\)
- 补码的范围是不对称的：\\( |TMin| = |TMax| + 1 \\)
- 最大的无符号数比最大的有符号数大 1

##### 反码

除了最高有效位的权是 \\( -(2^{w-1}-1) \\) 而不是 \\( -2^{w-1} \\)，它和补码是一样的 $$ B2O_w=-x\_{w-1}(2^{w-1}-1)+\sum\_{i=0}^{w-2}{x_i2^i} $$

##### 原码

最高有效位是符号位，用来确定剩下的位应该取负权还是正权

$$ 2S_w=(-1)^{x\_{w-1}}\cdot\sum\_{i=0}^{w-2}{x_i2^i} $$

- 反码和原码对于 0 都有两种不同的编码
  - \\( [0,0,0,...,0] \\) 都解释为 \\(+0\\)
  - -0 在原码中表示为 \\( [1,0,0,0,...,0] \\)
  - -0 在反码中表示为 \\( [1,1,1,1,...,1] \\)

#### 有符号数和无符号数之间的转换

强制类型转换的结果是保持位值不变，只是改变了解释这些位的方式。对于大多数 C 语言的实现，处理相同字长的有符号数和无符号数之间相互转换的一般规则是：数值有可能会改变，但是位模式不变。

补码转换为无符号数，对满足 \\( TMin_w \le x \le TMax_w \\) 的 \\(x\\) 有

$$
T2U_w(x)=\begin{cases}
x + 2^w, \ \ \ \ \ \ \  x \lt 0 \\\\
x, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \    x\ge 0 \\\\
 \end{cases}
$$

这就使得小于 0 的有符号数转换为补码时，发生了跳转，一下变得很大。

无符号数转为补码，对满足 \\( 0 \le u \le UMax_w \\) 的 \\(u\\) 有

$$
U2T_w(u)=\begin{cases}
u,\ \ \ \ \ \ \ \ \ \ \ \ \ u\le TMax_w \\\\
u - 2^w, \ \ \ \ u \gt TMax_w \\\\
 \end{cases}
$$

这就使得大于 \\(TMax_w\\) 的无符号数转化为补码时会发生跳转，一下变得很小。

在 C 语言中，当一个有符号数和一个无符号数进行计算时，会**隐式地将有符号数转化为无符号数**，并假设这两个数都是非负的，来执行这个计算，对于标准的算术运算来说并无多大差异，但是对于\\( \lt \\)和\\( \gt \\)这样的关系运算符来说，它会导致非直观的结果。
