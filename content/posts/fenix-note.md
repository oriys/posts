---
title: "凤凰架构"
date: 2021-07-01T01:54:35+08:00
draft: true
---

# 凤凰架构

[凤凰架构:​ 构建可靠的大型分布式系统](https://icyfenix.cn/)

## 探索起步

### 前端工程

#### 技术组件

- Vue.js：渐进式 JavaScript 框架
- Element：一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库
- Axios：Promise based HTTP client for the browser and node.js
- Mock.js：生成随机数据，拦截 Ajax 请求
- DesignEvo：一款由 PearlMountain 有限公司设计研发的 logo 设计软件

### 单体架构

#### 技术组件

- RESTFul: Jersey 2、 Apache CXF、RESTeasy、 WebSphere、WebLogic 等
- 依赖注入: JSR 330 标准注解
- 持久化: Spring Data JPA、Batoo JPA、EclipseLink、OpenJPA 等
- 数据验证: Hibernate Validator 6、Apache BVal 等
- Web 访问: Tomcat 9 Embed、Jetty、Undertow 等
- 授权: OAuth2、JWT、Spring Security
- 序列化: Jackson、Apache Johnzon、Eclipse Yasson、Gson

#### 工程结构

![](https://icyfenix.cn/images/ddd-arch.png)

- Resource:对应 DDD 中的 User Interface 层，负责向用户显示信息或者解释用户发出的命令。
- Application:对应 DDD 中的 Application 层，负责定义软件本身对外暴露的能力，即软件本身可以完成哪些任务，并负责对内协调领域对象来解决问题。
- Domain:对应 DDD 中的 Domain 层，负责实现业务逻辑，即表达业务概念，处理业务状态信息以及业务规则这些行为，此层是整个项目的重点。
- Infrastructure:对应 DDD 中的 Infrastructure 层，向其他层提供通用的技术能力，譬如持久化能力、远程服务通讯、工具集，等等。

### 微服务: Spring Cloud

#### 需求场景

- 整体和部分没有隔离，局部错误产生对整体的影响。
- 技术异构变得更加必要。

#### 工程结构

把单体的 Fenix's Bookstore 拆分成为“用户”、“商品”、“交易”三个能够独立运行的子系统，它们将在一系列非功能性技术模块（认证、授权等）和基础设施（配置中心、服务发现等）的支撑下互相协作，以统一的 API 网关对外提供与原来单体系统功能一致的服务

![](https://icyfenix.cn/images/springcloud-ms.png)

#### 技术组件

- 配置中心：默认采用 Spring Cloud Config，亦可使用 Spring Cloud Consul、Spring Cloud Alibaba Nacos 代替。
- 服务发现：默认采用 Netflix Eureka，亦可使用 Spring Cloud Consul、Spring Cloud ZooKeeper、Etcd 等代替。
- 服务网关：默认采用 Netflix Zuul，亦可使用 Spring Cloud Gateway 代替。
- 服务治理：默认采用 Netflix Hystrix，亦可使用 Sentinel、Resilience4j 代替。
- 进程内负载均衡：默认采用 Netfilix Ribbon，亦可使用 Spring Cloud Loadbalancer 代替。
- 声明式 HTTP 客户端：默认采用 Spring Cloud OpenFeign。声明式的 HTTP 客户端其实没有找替代品的必要性，如果需要，可考虑 Retrofit，或者使用 RestTemplete 乃至于更底层的 OkHTTP、HTTPClient 以命令式编程来访问，多写一些代码而已了。

### 微服务: Kubernetes

#### 需求场景

- 尽可能缩减非业务功能代码的比例。
- 尽可能在不影响原有的代码的前提下完成迁移。

#### 工程结构

本工程与此前基于 Spring Cloud 的实现没有丝毫差异，两者的每一行 Java 代码都是一模一样的；真正的区别在 Kubernetes 的实现版本中直接删除了配置中心、服务注册中心的工程，在其他工程的 pom.xml 中也删除了如 Eureka、Ribbon、Config 等组件的依赖。取而代之的是新增了若干以 YAML 配置文件为载体的 Skaffold 和 Kubernetes 的资源描述，这些资源描述文件，将会动态构建出 DNS 服务器、服务负载均衡器等一系列虚拟化的基础设施，去代替原有的应用层面的技术组件。升级改造之后的应用架构如下图所示：

![](https://icyfenix.cn/images//kubernetes-ms.png)

#### 技术组件

- 环境感知: Fabric8 Kubernetes Client
- 配置中心：Kubernetes 的 ConfigMap
- 负载均衡：Kubernetes Service
- 服务网关：服务网关：网关部分仍然保留了 Zuul，未采用 Ingress 代替。
- 服务熔断：仍然采用 Hystrix，Kubernetes 本身无法做到精细化的服务治理，包括熔断、流控、监视，等等
- 认证授权：仍然采用 Spring Security OAuth 2，Kubernetes 的 RBAC 授权可以解决服务层面的访问控制问题，但 Security 是跨越了业务和技术的边界的，认证授权模块本身仍承担着对前端用户的认证、授权职责，这部分是与业务相关的。

### 服务网格: Istio

#### 需求场景

- 实现在大规模虚拟服务下可管理、可观测的系统。
- 在代码层面，裁剪技术栈深度，回归单体架构中基于 Spring Boot 的开发模式，而不是 Spring Cloud 或者 Spring Cloud Kubernetes 的技术架构。

#### 工程结构

从升级目标可以明确地得到一种导向，我们必须控制住服务数量膨胀后传递到运维团队的压力，让“每运维人员能支持服务的数量”这个比例指标有指数级地提高才能确保微服务下运维团队的健康运作。对于开发团队，我们可以只要求一小部分核心的成员对微服务、Kubernetes、Istio 等技术有深刻的理解即可，其余大部分开发人员，仍然可以基于最传统、普通的 Spirng Boot 技术栈来开发功能。升级改造之后的应用架构如下图所示：

![](https://icyfenix.cn/images//istio-ms.png)

#### 技术组件

- 配置中心：通过 Kubernetes 的 ConfigMap 来管理。
- 服务发现：通过 Kubernetes 的 Service 来管理，由于已经不再引入 Spring Cloud Feign 了，所以在 OpenFeign 中，直接使用短服务名进行访问。
- 负载均衡：未注入边车代理时，依赖 KubeDNS 实现基础的负载均衡，一旦有了 Envoy 的支持，就可以配置丰富的代理规则和策略。
- 服务网关：依靠 Istio Ingress Gateway 来实现，已经移除了 Kubernetes 版本中保留的 Zuul 网关。
- 服务容错：依靠 Envoy 来实现，已经移除了 Kubernetes 版本中保留的 Hystrix。
- 认证授权：依靠 Istio 的安全机制来实现，实质上已经不再依赖 Spring Security 进行 ACL 控制，但 Spring Security OAuth 2 仍然以第三方 JWT 授权中心的角色存在，为系统提供终端用户认证，为服务网格提供令牌生成、公钥 JWKS 等支持。

### 无服务：AWS Lambda

无服务架构（Serverless）与微服务架构本身没有继承替代关系，它们并不是同一种层次的架构，无服务的云函数可以作为微服务的一种实现方式，甚至可能是未来很主流的实现方式。不过，由于无服务架构原理上就决定了它对程序的启动性能十分敏感，这天生就不利于 Java 程序，尤其不利于 Spring 这类启动时组装的 CDI 框架。因此基于 Java 的程序，除非使用 GraalVM 做提前编译、将 Spring 的大部分 Bean 提前初始化，或者迁移至 Quarkus 这以原生程序为目标的框架上，否则是很难实际用于生产的。

## 服务架构演进史

### 原始分布式时代

- 分布式运算环境(Distributed Computing Environment，DCE)
- 使分布式环境中的服务调用、资源访问、数据存储等操作尽可能透明化、简单化，如同调用本地方法一样。
- “调用远程方法”与“调用本地方法”无法同时兼顾简单、透明、性能、正确、鲁棒、一致等特点。
- 远程调用存在的问题
  - 服务发现
  - 负载均衡
  - 网络分区
  - 熔断、隔离、降级
  - 序列化协议
  - 传输协议
  - 服务认证
  - 通信安全
  - 分布式数据一致性
- 将一个系统拆分到不同的机器中运行，这样做带来的服务发现、跟踪、通信、容错、隔离、配置、传输、数据一致性和编码复杂度等方面的问题，所付出的代价远远超过了分布式所取得的收益。
- 某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作，只会自寻苦果。

### 单体系统时代

- 单体只是表明系统中主要的过程调用都是进程内调用，不会发生进程间通信，仅此而已。
- 是出现时间最早、应用范围最广、使用人数最多、统治历史最长的一种架构风格
- 单体不仅易于开发、易于测试、易于部署，且由于系统中各个功能、模块、方法的调用过程都是进程内调用，不会发生进程间通信 ，因此也是运行效率最高的一种架构风格。
- 分层架构：收到的外部请求在各层之间以不同形式的数据结构进行流转传递，触及最末端的数据库后按相反的顺序回馈响应。
- 应用内局部的问题波及到整个应用甚至其他共享资源的应用。
- 升级不便、做灰度发布和 A/B 测试相对复杂。
- 单体技术异构难度大。
- 单体依靠高质量保证高可靠性的思路在系统越来越大的现在收到了挑战。
- 允许程序出错，萎了获得隔离、自治、技术异构的能力，以及性能和算力，程序走向了分布式的道路。

### SOA 时代

- 烟囱式架构：一种完全不与其他相关信息系统进行互操作或者协调工作的设计模式
- 微内核架构：将公共服务、数据、资源集中到一块，成为一个被所有业务系统共同依赖的核心 (Kernel，也称为 Core System)，具体的业务系统以插件模块(Plug-in Modules)的形式存在
- 事件驱动架构：在子系统之间建立一套事件队列管道(Event Queues)，来自系统外部的消息将以事件的形式发送至管道中，各个子系统从管道里获取自己感兴趣、能够处理的事件消息，也可以为事件新增或者修改其中的附加信息，甚至可以自己发布一些新的事件到管道队列中去。
- 软件架构来到 SOA 时代，许多概念、思想都已经能在今天微服务中找到对应的身影了，譬如服务之间的松散耦合、注册、发现、治理，隔离、编排，等等。
- 构成了一套软件设计的基础平台，利用一套相关的系统来解决分布式下的问题
- SOAP 协议被逐渐边缘化的本质原因: 过于严格的规范定义带来过度的复杂性。

### 微服务时代

- 微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。
- 早期的微服务是作为一种 SOA 的轻量化的补救方案而被提出的。
- 微服务的九个业务和技术特征
  - 围绕业务能力构建：康威定律，有怎样结构、规模、能力的团队，就会产生出对应结构、规模、能力的产品。
  - 分散治理：服务对应的开发团队有直接对服务运行质量负责的责任，也应该有着不受外界干预地掌控服务各个方面的权力。
  - 通过服务来实现独立自治的组件：尽管远程服务有更高昂的调用成本，但这是为组件带来隔离与自治能力的必要代价。
  - 产品化思维：团队应该为软件产品的整个生命周期负责。
  - 数据去中心化：微服务明确地提倡数据应该按领域分散管理、更新、维护、存储。
  - 强终端弱管道：如果服务需要上面的额外通信能力，就应该在服务自己的 Endpoint 上解决，而不是在通信管道上一揽子处理。
  - 容错性设计：不再虚幻地追求服务永远稳定，而是接受服务总会出错的现实，要求在微服务的设计中，有自动的机制对其依赖的服务能够进行快速故障检测，在持续出错的时候进行隔离，在服务恢复的时候重新联通。
  - 演进式设计：容错性设计承认服务会出错，演进式设计则是承认服务会被报废淘汰。一个设计良好的服务，应该是能够报废的，而不是期望得到长存永生。
  - 基础设施自动化：基础设施自动化，如 CI/CD 的长足发展，显著减少了构建、发布、运维工作的复杂性。

### 后微服务时代

- 虚拟化技术和容器化技术
- 2017 年 Kubernetes 赢得容器战争
- 虚拟化的基础设施从单个服务的容器扩展至由多个容器构成的服务集群、通信网络和存储设施时，软件与硬件的界限便已经模糊。
- 为了精细化管理流量的需求，虚拟化的基础设施很快完成了第二次进化，引入了今天被称为“服务网格 ”(Service Mesh)的“边车代理模式”(Sidecar Proxy)

### 无服务时代

- 无服务是以“简单”为主要卖点的，它只涉及两块内容:后端设施(Backend)和函数(Function)。
  - 后端设施是指数据库、消息队列、日志、存储，等等这一类用于支撑业务逻辑运行，但本身无业务含义的技术组件，这些后端设施都运行在云中，无服务中称其为“后端即服务”(Backend as a Service，BaaS)。
  - 函数是指业务逻辑代码，这里函数的概念与粒度，都已经很接近于程序编码角度的函数了，其区别是无服务中的函数运行在云端，不必考虑算力问题，不必考虑容量规划，无服务中称其为“函数即服务”(Function as a Service，FaaS)。
- 无服务的愿景是让开发者只需要纯粹地关注业务，不需要考虑技术组件，后端的技术组件是现成的，可以直接取用，没有采购、版权和选型的烦恼;不需要考虑如何部署，部署过程完全是托管到云端的，工作由云端自动完成;不需要考虑算力，有整个数据中心支撑， 算力可以认为是无限的;也不需要操心运维，维护系统持续平稳运行是云计算服务商的责任而不再是开发者的责任。

## 访问远程服务

### 远程服务调用

- Java 执行本地调用
  - 传递方法参数
  - 确定方法版本
  - 执行被调方法
  - 返回执行结果
- 进程间通信
  - 管道或者具名管道
  - 信号
  - 信号量
  - 消息队列
  - 共享内存
  - 套接字接口
- 通信的成本
  - 两个进程通信，谁作为服务端，谁作为客户端?
  - 怎样进行异常处理?异常该如何让调用者获知?
  - 服务端出现多线程竞争之后怎么办?
  - 如何提高网络利用的效率，譬如连接是否可被多个请求复用以减少开销?是否支持多播?
  - 参数、返回值如何表示?应该有怎样的字节序?
  - 如何保证网络的可靠性?
  - 譬如调用期间某个链接忽然断开了怎么办?
  - 发送的请求服务端收不到回复该怎么办?
- 通过网络进行分布式运算八宗罪
  - The network is reliable —— 网络是可靠的。
  - Latency is zero —— 延迟是不存在的。
  - Bandwidth is infinite —— 带宽是无限的。
  - The network is secure —— 网络是安全的。
  - Topology doesn't change —— 拓扑结构是一成不变的。
  - There is one administrator —— 总会有一个管理员。
  - Transport cost is zero —— 不必考虑传输成本。
  - The network is homogeneous —— 网络是同质化的。
- 三个基本问题
  - 如何表示数据:这里数据包括了传递给方法的参数，以及方法执行后的返回值。无论是 将参数传递给另外一个进程，还是从另外一个进程中取回执行结果，都涉及到它们应该 如何表示。
    - ONC RPC 的 External Data Representation (XDR)
    - CORBA 的 Common Data Representation (CDR)
    - Java RMI 的 Java Object Serialization Stream Protocol
    - gRPC 的 Protocol Buffers
    - Web Service 的 XML Serialization
    - 众多轻量级 RPC 支持的 JSON Serialization
  - 如何传递数据:通过网络，在两个服务的 Endpoint 之间相互操 作、交换数据。
    - Java RMI 的 Java Remote Message Protocol (JRMP，也支持 RMI-IIOP )
    - CORBA 的 Internet Inter ORB Protocol (IIOP，是 GIOP 协议在 IP 协议上的实现 版本)
    - DDS 的 Real Time Publish Subscribe Protocol (RTPS)
    - Web Service 的 Simple Object Access Protocol (SOAP)
    - 如果要求足够简单，双方都是 HTTP Endpoint，直接使用 HTTP 协议也是可以的 (如 JSON-RPC)
  - 如何确定方法:语言无关的接口描述语言
    - Android 的 Android Interface Definition Language (AIDL)
    - CORBA 的 OMG Interface Definition Language (OMG IDL)
    - Web Service 的 Web Service Description Language (WSDL)
    - JSON-RPC 的 JSON Web Service Protocol (JSON-WSP)
- 统一的 RPC
  - DCE/RPC：不支持传递对象
  - ONE RPC：不支持传递对象
  - CORBA：太过啰嗦，脱离实际，厂商之间不兼容
  - Web Service：需要客户端，性能差，大量冗余信息，沉重的学习负担
- 分裂的 RPC
  - 朝着面向对象发展
    - RMI、.NET Remoting
  - 朝着性能发展
    - gRPC 和 Thrift，序列化效率和信息密度高，gRPC 和 Thrift 都有自己优秀的专有序列化器，而传输协议方面，gRPC 是基于 HTTP/2 的，支持多路复用和 Header 压缩，Thrift 则直接基于传输层的 TCP 协议来实现，省去了额外应用层协议的开销
  - 朝着简化发展
    - JSON-RPC，牺牲了功能和效率，换来的是协议的简单轻便，接口与格式都更为通用
- RPC 趋势
  - 到了最近几年，RPC 框架有明显的朝着更高层次(不仅仅负责调用远程服务，还管理远程服务)与插件化方向发展的趋势，不再追求独立地解决 RPC 的全部三个问题(表示数据、传递数据、表示方法)，而是将一部分功能设计成扩展点，让用户自己去选择。框架聚焦于提供核心的、更高层次的能力，譬如提供负载均衡、服务注册、可观察性等方面的支持。

## REST 设计风格

### 理解 REST

- REST 是风格而不是规范、协议
- 资源(Resource)：网页、文稿等信息
- 表征(Representation)：资源表现的形式
- 状态(State)：特定语境下的上下文信息
- 转移(Transfer)：服务端拥有该资源及其表征形式。服务器通过 某种方式，把“用户当前阅读的文章”转变成“下一篇文章”，这就被称为“表征状态转移”。
- 统一接口(Uniform Interface)：HTTP 协议中已经提前约定好了一套“统一接口”，它包括:GET、HEAD、POST、PUT、DELETE、TRACE、OPTIONS 七种基本操作，任何一个支持 HTTP 协议的服务器都会遵守这套规定，对特定的 URI 采取这些操作，服务器就会触发相应的表征状态转移。
- 超文本驱动(Hypertext Driven)：浏览器作为所有网站的通用的客户端，任何网站的导航(状态转移)行为都不可能是预置于浏览器代码之中，而是由服务器发出的请求响应信息(超文本)来驱动的。
- 自描述消息(Self-Descriptive Messages):由于资源的表征可能存在多种不同形态，在消息中应当有明确的信息来告知客户端该消息的类型以及应如何处理这条消息。

### RESTFul 的系统

- 服务端与客户端分离(Client-Server)
  - 将用户界面所关注的逻辑和数据存储所关注的逻辑分离开
- 无状态(Stateless)
  - REST 希望服务器不要去负责维护状态，每一次从客户端发送的请求中，应包括所有的必要的上下文信息，会话信息也由客户端负责保存维护，服务端依据客户端传递的状态来执行业务处理逻辑，驱动整个应用的状态变迁。
- 可缓存(Cacheability)
  - REST 希望软件系统能够如同万维网一样，允许客户端和中间的通讯传递者(譬如代理)将部分服务端的应答缓存起来。当然，为了缓存能够正确地运作，服务端的应答中必须明确地或者间接地表明本身是否可以进行缓存、可以缓存多长时间，以避免客户端在将来进行请求的时候得到过时的数据。
- 分层系统(Layered System)
  - 客户端一般不需要知道是否直接连接到了最终的服务器，抑或连接到路径上的中间服务器。中间服务器可以通过负载均衡和共享缓存的机制提高系统的可扩展性，这样也便于缓存、伸缩和安全策略的部署。
- 统一接口(Uniform Interface)
  - 软件系统设计的重点放在抽象系统该有哪些资源上，而不是抽象系统该有哪些行为(服务)上。
- 按需代码(Code-On-Demand)
  - 任何按照客户端(譬如浏览器)的请求，将可执行的软件程序从服务器发送到客户端的技术，按需代码赋予了客户端无需事先知道所有来自服务端的信息应该如何处理、如何运行的宽容度。

### REST 的优点

- 降低的服务接口的学习成本。
- 资源天然具有集合与层次结构。
- REST 绑定于 HTTP 协议。

### REST 的不足与争议

- 面向资源的编程思想只适合做 CRUD，面向过程、面向对象编程才能处理真正复杂的业务逻辑
- REST 与 HTTP 完全绑定，不适合应用于要求高性能传输的场景中
- REST 不利于事务支持
- REST 没有传输可靠性支持
- REST 缺乏对资源进行“部分”和“批量”的处理能力