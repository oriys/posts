---
title: "深入理解Java虚拟机::自动内存管理"
date: 2021-04-01T22:10:56+08:00
draft: false
keywords: ["JVM内存管理", "Java堆", "垃圾回收", "运行时数据区", "对象创建"]
---

## 自动内存管理

- 程序计数器
  - 程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器
  - 每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存
  - 如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址
  - 如果正在执行的是本地(Native)方法，这个计数器值则应为空(Undefined)
- Java 虚拟机栈
  - 线程私有的
  - 生命周期与线程相同
  - 每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息
  - 局部变量表存放了编译期可知的各种 Java 虚拟机基本数据类型、对象引用和 returnAddress 类型
  - StackOverflowError
  - OutOfMemoryError
- 本地方法栈
  - 虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务
  - StackOverflowError
  - OutOfMemoryError
- Java 堆
  - Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建
  - 此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存
    - 逃逸分析，栈上分配，标量替换
  - 垃圾收集器管理的内存区域
    - 分代收集理论
  - 所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区 TLAB 以提升对象分配时的效率
  - Java 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的
  - OutOfMemoryError
- 方法区
  - 线程共享
  - 存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据
  - 可以选择不实现垃圾收集
  - 内存回收目标主要是针对常量池的回收和对类型的卸载
- 运行时常量池
  - 方法区的一部分
  - 存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中
  - 具备动态性
  - OutOfMemoryError
- 直接内存
  - 不是虚拟机运行时数据区的一部分
  - 在 JDK 1.4 中新加入了 NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区 (Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作
  - 不会受到 Java 堆大小的限制
  - OutOfMemoryError
- 对象的创建
  - 当 Java 虚拟机遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程
  - 对象所需内存的大小在类加载完成后便可完全确定
    - 对象分配空间的任务实际上便等同于把一块确定大小的内存块从 Java 堆中划分出来
    - 假设 Java 堆中内存是绝对规整的--指针碰撞
    - 如果 Java 堆中的内存并不是规整的--空闲列表
    - 选择哪种分配方式由 Java 堆是否规整决定
      - Java 堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理(Compact)的能力决定
      - 指针碰撞
        - Serial、ParNew 等带压缩整理过程的收集器
      - 空闲列表
        - 使用 CMS 这种基于清除(Sweep)算法的收集器
    - 在虚拟机中对象创建的线程安全
      - 对分配内存空间的动作进行同步处理
      - 内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer，TLAB)，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定
    - 内存分配完成之后虚拟机必须将分配到的内存空间(但不包括对象头)都初始化为零值
    - 对对象进行必要的设置
  - new 指令之后会接着执行<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来
- 对象的内存布局
  - 对象头(Header)
    - 对象自身的运行时数据
      - 哈希码(HashCode)
      - GC 分代年龄
      - 锁状态标志
      - 线程持有的锁
      - 偏向线程 ID
      - 偏向时间戳
    - 类型指针
      - 指向它的类型元数据的指针
      - 记录数组长度的数据
  - 实例数据(Instance Data)
    - 程序代码里面所定义的各种类型的字段内容
      - 父类继承下来的
      - 子类中定义的字段
  - 对齐填充(Padding)
    - 不是必然存在的
    - HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍
- 对象的访问定位
  - 使用句柄访问
    - Java 堆中将可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息
  - 使用直接指针访问
    - 考虑如何放置访问类型数据的相关信息
    - reference 中存储的直接就是对象地址
    - 速度更快，它节省了一次指针定位的时间开销
