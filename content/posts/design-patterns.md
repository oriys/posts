---
title: "设计模式笔记"
date: 2021-06-01T18:13:16+08:00
draft: true
---

## 设计模式分类

`创建型模式`提供创建对象的机制，增加已有代码的灵活性和可复用性。

`结构型模式`介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。

`行为模式`负责对象间的高效沟通和职责委派。

## 创造型模式

### 工厂方法模式

定义

工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”

UML

![](../../../design_patterns/FactoryMethod.svg)

代码示例

```java
public class ProductFactory {
    public static Product ProductFactoryMethod(ProductType type) {
        Product product = null;
        switch (type) {
            case ProductFactory.A:
                product = new ProductA();
            case ProductFactory.B:
                product = new ProductB(is);
            //...
        }
        return product;
    }
}
```

适用场景

- 创建对象需要大量重复的代码。可以把这些代码写在工厂基类中。
- 创建对象需要访问某些信息，而这些信息不应该包含在复合类中。
- 创建对象的生命周期必须集中管理，以保证在整个程序中具有一致的行为。对象创建时会有很多参数来决定如何创建出这个对象。
- 业务对象的代码作者希望隐藏对象的真实类型，而构造函数一定要真实的类名才能用
- 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。

优点

- 你可以避免创建者和具体产品之间的紧密耦合。
- 单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。
- 开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。

缺点

- 应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更复杂。最好的情况是将该模式引入创建者类的现有层次结构中。
- 并没有降低代码复杂度，只是将创建的复杂度从使用中中转移到了工厂方法中。
